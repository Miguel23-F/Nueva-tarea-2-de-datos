import numpy as np
from Secuenciable import Secuenciable
import libro as L
from typing import TypeVar
from Orden_secuencia import quick_sort

T = TypeVar('T')


class Secuencia(Secuenciable):

    def __init__(self, *params):
        if len(params) == 0:  # Constructor por omisión
            self.__datos = np.empty(30, dtype=L.Libro)
            self.__nd = 0
            print("Se creo una secuencia para 20 elementos!\n")
        elif len(params) == 1:  # Constructor por parámetros
            try:
                self.__datos = np.empty(params[0], dtype=L.Libro)
                self.__nd = 0
                print(f"Se creo una secuencia para {params[0]} elementos!\n")
            except ValueError:
                print("El tamaño del arreglo debe ser positivo!\n")

    def __iter__(self):
        self.pos = 0
        return self

    def __next__(self) -> L.Libro:
        if self.pos < self.nd:
            a = self.datos[self.pos]
            self.pos += 1
            return a
        else:
            raise StopIteration

    # Métodos GET

    @property
    def datos(self):
        return self.__datos

    @property
    def nd(self) -> int:
        return self.__nd

    # Métodos calculadores

    def agregar1(self, elemento: T):
        try:
            self.__datos[self.__nd] = elemento
            self.__nd += 1
        except IndexError:
            print("No es posible agregar un elemento!\n")
        pass

    def agregar2(self, elemento: T, nveces: int):
        it1 = iter(self)
        i = 0
        try:
            while i <= nveces-1:
                self.__datos[self.__nd] = next(it1)
                self.__nd += 1
                i += 1
        except StopIteration:
            print("No es posible agregar un elemento!\n")

    def contiene(self, valor: T) -> bool:
        inicio = 0
        fin = len(self.__datos) - 1

        while inicio <= fin:
            medio = (inicio + fin) // 2

            if self.__datos[medio] == valor:
                return True  # Lo encontró
            elif self.__datos[medio] < valor:
                inicio = medio + 1
            else:
                fin = medio - 1

    def repeticiones(self, elemento: T) -> int:
        if self.contiene(elemento):
            it1 = iter(self)
            repeticiones = 0
            try:
                while True:
                    elem = next(it1)
                    if elem == elemento:
                        repeticiones += 1
            except StopIteration:
                pass
            return repeticiones
        else:
            return 0

    def __encuentra(self, valor: T) -> int:
        inicio = 0
        fin = len(self.__datos) - 1

        while inicio <= fin:
            medio = (inicio + fin) // 2

            if self.__datos[medio] == valor:
                return medio  # Lo encontró
            elif self.__datos[medio] < valor:
                inicio = medio + 1
            else:
                fin = medio - 1

    def eliminar1(self, elemento: T):
        if self.contiene(elemento):
            while True:
                pos=self.__encuentra(elemento)
                if pos==self.__nd:
                    self.__nd -= 1
                    continue
                elif pos!= self.__nd and type(pos)==int:
                    self.__datos[self.__nd], self.__datos[pos] = self.__datos[pos], self.__datos[self.__nd]
                    self.__nd -= 1
                    continue
                else:
                    break
        else:
            print("El elemento no se encuentra en la secuencia\n")

    def eliminar2(self, elemento: T, nrep: int):
        if nrep<=self.repeticiones(elemento):
            it1=iter(self)
            i=0
            try:
                while i<=nrep-1:
                    pos = self.__encuentra(elemento)
                    if pos == self.__nd:
                        self.__nd -= 1
                        i+=1
                        continue
                    elif pos != self.__nd and type(pos) == int:
                        self.__datos[self.__nd], self.__datos[i] = self.__datos[i], self.__datos[self.__nd]
                        i+=1
                        continue
                    else:
                        break
            except StopIteration:
                pass
        else:
            print(f"El elemento no se encuentre en la secuencia al menos {nrep} veces\n")

    def esta_vacia(self) -> bool:
        if self.__nd == 0:
            return True

    def cardinalidad(self) -> int:
        return self.__nd

    def vaciar(self):
        self.__nd = 0

    def secuencia_unico(self):
        it1=iter(self)
        try:
            while True:
                elem = next(it1)
                reps = self.repeticiones(elem)
                self.eliminar2(elem, reps-1)
        except StopIteration:
            pass

    def ordenar(self, comparador):
        arreglo = self.__datos.copy()
        if len(arreglo) > 1:
            orden = quick_sort(arreglo.copy(), 0, self.__nd - 1, comparador)
            for libro in orden:
                if libro is not None:
                    print(libro)
            print()
        else:
            return arreglo
